一些算法知识点

1. 递归是一个大的范畴，需要满足可以拆分为子问题
2. 动态规划需要满足三个条件：
    1、具有最优子结构；2、无后效性 3、重复子问题。

最优子结构是指一个问题的最优解，也包含了它子问题的最优解，那么就是具有最优子结构。一般会以最大最小出现，而不会以绝对值的形式出现。
无后效性包含两个含义，一是在推导后面的状态时候，只和当前状态有关，至于之前的状态怎么到达当前状态的无关影响；二是之后的状态变化不会影响之前的状态。这里的状态是我们定义的，比如斐波拉契数列 f(n) = f(n-1) + f(n-2)就是把f(n-1)和f(n-2)合并为一个状态。
重复子问题是动态规划常见的以空间换时间，只有在有大量重复计算的时候，才有存储的必要。而向merge sort就没有动态规划的必要，而只是递归

3. 使用递归的时候，如果遇上数组，比如backtrack，那么在递归函数传一个数组和对应的开始结束index，可以减少很多不必要的copy
4. 几种用stack的题型，都是能够化为next greater number的题型
    如654.Maximum Binary Tree，1130.min_cost_tree_from_leaf_value

对于数组排序，可以直接用 Arrays.sort(intervals, (i1, i2) -> Integer.compare(i1[0], i2[0]));
对于数组初始化，可以直接用 Arrays.fill(nums, 1);

初始化二维数组，双大括号
int[][] direction = {{0,1}, {1,0}, {0,-1}, {-1,0}};